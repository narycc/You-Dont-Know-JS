# 你不知道的JS：起步
# 第2章： 深入JavaScript

在之前的章节中，我介绍了筑立编程的基本砖块：变量，循环，条件语句和函数。当然，所有的示例都是用JavaScript 语言写的。但是在这一章节中，我们会着重关注作为一个JS开发者需要专门了解的JavaScript特性上。

我们将会在这章节中介绍一些后续*YDKJS*系列中才会深入探讨的概念。你可以把它们视作这一系列后续详细介绍的主题的概览。

尤其是作为一个JavaScript初学者，你应该花上足够的时间反复巩固这些概念和代码示例。好的基础都是一块块砖垒起来的，不要寄希望于一步通天。

你深入学习JavaScript 之旅在此启程。

**说明** 就像我在第1章所述，本章所有涉及到的代码你都应该亲自动手尝试。注意这里的一些代码部分使用了截止到写这本书时候最新的一些JavaScript 语法（ES6 一般指ECMAScript 第6版，JS规格说明书的官方名字）。如果你正在使用的浏览器比较陈旧，ES6 浏览器之前的版本，这些代码可能无法正常运行，那么请更新浏览器版本（如Chrome，firefox，或者IE）。 

## 值与类型

正如在第1章中所述，JavaScript 的值是有类型的，变量是没有类型的。以下是内置的类型：

* `string`
* `number`
* `boolean`
* `null` 和 `undefined`
* `object`
* `symbol` （ES6 新增）

JavaScript 有一个typeof 操作符，可以检测值的所属类型。

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

typeof 操作符返回的值总是六个字符串（ES6 的话是7个，还有symbol 类型）中的一个。 `typeof "abc"` 返回的是 `"string"`而不是`string`。

注意，这个代码片段中，a 变量的值是不同的，虽然看起来是一样的`typeof a`，但它不是获取`a` 的类型，而是当前a 变量中存储的值的类型。JavaScript 中只有值有类型，变量只是那些值的一个容器。

`typeof null`比较有趣，可能你会认为它会返回`"null"`，但意外的返回`"object"`。

**警告** 这个bug 在JS中已经存在很久了，但是看起来似乎永远不会被修复了。web中有太多的代码依赖这个这个bug 了，因此一旦修复会引起更多的bug。

同时，注意`a = undefined`，我们显式地给a 设置为undefined ，这种行为跟没有赋值的变量的结果是一样的，如最上面的代码`var a;`。有多种方式将一个变量设置为undefined 状态，包括没有返回值的函数和使用`void` 操作符。

### 对象

`object` 是一个复合值，你可以给它设置属性，并且每个属性可以有任何类型的值。它或许是JavaScript 所有类型中最有用的值类型了。

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

直观地来看这个`obj` 的值：

<img src="fig4.png">

属性可以通过点操作符（`obj.a`）也可以通过方括号引用（`obj["a"]`）来获取。通常更倾向于使用点操作符，因为更短通常也更易读。

方括号引用在属性名字为特殊字符串的时候很有用，比如`obj["hello world!"]`， 这样的属性成为方括号引用的*键*。`[ ]`引用需要一个变量或字符串字面值（常用`" .. "` 或 `' .. '`包裹）。

当然，当键名或者属性名存储在另一个变量中的时候，方括号引用也非常实用，如：
```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**说明** 关于JavaScript `object` 的更多信息，参见这一些列标题为“this 与对象原型” 的内容第三章节。

JavaScript 程序中你通常还会使用到其他值类型：*数组* 和 *函数*。与其说他们是内建类型，到不如说它们更像是子类型，专指 object 类型的子类型。

#### 数组

数组是一个包含多个不是以属性名或键名而是以数字索引值的对象。比如：

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```


**说明** 一些以 0 作为计数开始的语言，比如JS，把0 作为数组第一个元素的索引位置。

直观地来看这个`arr` 的值：

<img src="fig5.png">

数组是特殊的对象（参考 typeof ），它们也可以有属性，包括自动更新的length 属性。

理论上你可以把数组当一个正常的对象使用，提供属性名；类似地你也可以给对象设置数字属性（`0`， `1` 等）。但是，这些都会被视作对应类型使用不当的结果。

数字位置索引的值用数组存储，有属性名的值用对象存储，这是最好最自然的方式。

#### 函数

你的JS程序中会使用到的另外一个`object`子类型是函数：

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

`typeof` 返回 `"function"`表明函数是一个主类型。函数是`object` 的子类型，因此可以有属性值，但是一般你只能在某些情况下使用函数的对象属性（如`foo.bar`）。

**说明** 关于JS值和它们的类型的更多信息，参见这一系列标题为 “值与语法” 的内容前两章节。

### 内建类型方法

我们刚刚讨论的内建类型和子类型暴露出来的属性和方法非常强大非常有用。例如：

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

`a.toUpperCase()` 背后是如何调用的远比方法返回出来的值要复杂的多。

简单地讲，有一个原生的`String`对象封装，与原始的`string` 类型对应，是这个对象封装在它的原型上定义了`toUpperCase()` 方法。

当你使用原始的值如`"hello world"` 作为对象，并调用属性或者方法（如之前代码片段中的 `a.toUpperCase()`），JS 自动地将这个值封装成对象副本。

一个字符串值可以被`String` 对象封装，一个数字可以被`Number`对象封装，一个布尔值可以被`Boolean` 封装。大多数情况，你不用操心如何使用这些值的对象封装形式，任何情况下直接使用原始值的形式， 剩下的就交给JavaScript 就好了。

**说明** 关于JS 原生类型和封装的更多信息，参见这一系列标题为“类型与语法”内容的第3章。 为了更好地理解对象的原型，参见这一系列标题为“this 与对象原型”内容的第5章。

### 值比较

JS程序中有两种主要的值比较类型： 等式与不等式。 不管什么类型的值比较的结果都是严格的布尔类型（true 或false）。

#### 强制转换

我们在第1章节中简要的提及了下强制转换，这里让我们再来看看。

JavaScript 强制转换由两种形式组成：显式和隐式。 显式强制转换指那些你可以明显在代码中看到的从一种类型转换成另一种类型的情况；隐式强制转换是在执行某些操作时发生地不明显的类型转换。

或许事实中很多地方给我们一个结论，“强制转换是魔鬼”，因为他会引起令人意想不到的结果。而没有什么比语言的结果让他们意想不到更令程序员受挫的了。

强制不是魔鬼，它也不是非得让人感到意外。事实上大多数情况下我们进行的类型转换都是非常有意义且易懂的，甚至对提高代码的可读性有很大帮助。但是，我们不会在这里过多的为这个问题争论， 这一系列标题为“类型与语法”的第4章涵盖了所有的优缺点。

这里有一个显式强制转换的例子：

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

这个是隐式强制转换的例子：

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真与假

第1章中，我们简要地提及了值的“真”与“假”本质：当一个非布尔值强制转化成一个布尔值时，它非真即假。

JavaScript 为 false 的值如下：

* `""` （空字符串）
* `0`， `-0`， `NaN` （非法 `number`）
* `null`， `undefined`
* `false`

所有不在上列为“假”中的值，那就是“真”。这是一些例子：

* `"hello"`
* `42`
* `true`
* `[ ]`， `[ 1, "2", 3 ]`（数组）
* `{ }`， `{ a: 42 }`（对象）
* `function foo() { .. }` （函数）

记住，当一个非布尔值强制转化成布尔值的时候只能是“真”或者“假”。并不会有那么复杂，不会有把一个值强制转化成布尔值却不会得到布尔值的情况。

#### 等式

有四种等式表达式： `==`， `===`， `!=`，和 `!==`。`！` 格式的表达式自然是不等于的意思。要区分不等于和不等式的概念。

`==` 和 `===` 的区别是， `==` 检查值是否相等，`===` 检查值和类型是否都相等。但并不完全准确。它们正确的使用方式是允许强制转化检查值是否相等时用 `==`，不允许强制转化检查值是否相等时使用`===`， 因为`===`通常称为严格的相等。

隐式强制转化比较时使用 `==` ，而不能使用严格相等`===`。

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

进行`a == b`比较时，JS发现两者的类型不一样，因此会进行一系列步骤把一个或者两个值转化别的类型，直到它们两者的类型一致，然后再进行简单的值比较。

你想一下就会直到有两种可能的方式让`a==b` 强制转换之后返回true。要么最后变成`42 == 42`的形式，要么变成`"42" == "42"`。那到底是哪一种呢？

答案是`"42"` 变成了 `42`，最后进行的比较是：`42 == 42`。这个简单的例子中，到底是数字转换成字符串进行比较还是字符串转化成数字进行比较不是很关键，因为结果都是一样。更复杂的情况是我们不仅要关心最终的比较结果是什么，还要知道为什么。

`a === b` 的结果是false， 因为不允许强制转换，那么进行简单的值比较肯定是不相等的。很多开发者觉得`===`比较的结果更好预测，因此他们提倡大家始终使用`===` ，远离`==`。我觉得这种观点是非常短视的。我相信`==`非常强大，如果你花时间去学习它的机制，对你的程序是很有帮助的。

我们不准备在这里详细地讨论`==`比较中的强制转化是怎么工作的。大部分很明显，但仍然有一些重要的极端情况需要仔细对待。关于确切的规则，阅读 [ES5 规格说明书的11.9.3章节](http://www.ecma-international.org/ecma-262/5.1/)，你会惊讶地发现比起它那些被放大的缺点，这个机制是多么的直接。

总结所有的细节，为了应对各种使用情况到底使用`==` 还是`===` ，下面是我的一些结论规律：

* 如果比较的两边的值都不是true 或者false， 使用`====`,避免使用`==`；
* 如果比较的任何一边有出现特定的值（`0`，`""` 或 `[]`空数组）使用`===`，避免使用`==`；
* `==`在所有其他情况使用都是安全的，不仅安全，而且多数情况下能简化你的代码提高可读性。

以上总结这些结论都需要你谨慎思考你的代码，进行等式比较的变量的值类型是什么。如果你能确定值，并且`==`是安全的，那么就用`==`。如果你不确定值，那么就使用`===`。就是这么简单。

不等号`!=`与`==`对应，`!==`与`===`对应。我们上面讨论的所有规则和观察结果都适用于这些不等于比较。

当你对两个非原始值进行比较的时候，比如对象（包括函数和数组），你必须特别注意`==` 和`===`的比较规则。因为这些值事实上是保存在引用中，`==` 和 `===`都会去检查引用是否相等，而不只是他们对应的值。

例如，`array` 默认会按照把数组中所有的元素以逗号的形式拼接起来强制转化成字符串。你可能会觉得两个内容相同的数组`==` 比较会相等，但并非如此：

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

**说明** 更多关于`==`等式比较的规则，参见 ES5 规格说明书（11.9.3小节）和 这一系列“类型与语法”内容的第4章节。更多关于值和引用的内容，参见第2章。

#### 不等式

不等式，在规格说明书中被称为关系比较，使用`<`， `>`， `<=` 和 `>=` 运算符。通常被用来进行普通的值比较，如数字。通俗易懂，如`3 < 4`。

但是JavaScript 的string 类型值也能按照字母顺序规则进行不等式比较（`"bar" < "foo"`）。

那么强制转化呢？不等式的比较规则跟`==`类似。和“严格相等”`===` 不支持强制转换一样， “严格不等”运算符也不支持强制转换。

参见：

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

这里发生了什么呢？ 在ES5 规格说明书的 11.8.5 章节中阐述，如果`<`两遍的值都是字符串类型，像这里的`b < c`，是按照字典序比较的。但是只要有一边不是字符串，像这里的`a < b`，那么两边的值都会被强制转化成数字，然后就成变了典型的数字比较。

这里没有“严格的不等式”，你在不同值类型比较中的可能会遇到的最大问题是，其中的一个值不能转化成有效的数字，比如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等等，怎么会这三个比较都返回false 呢？ 因为在`<`，`>`比较中b 被强制转化成非法的数字`NaN`，JS规格说明书中说，NaN 既不会大于也不会小于任何值。

`==` 不成立是因为别的原因。如之前解释的，如果比较被转换成`42 == NaN` 或 `"42" == "foo"`那么`a == b`就不会成立，这里就是`42 == NaN`。

**说明** 想了解更多关于不等式比较规则的详细信息，参见ES5规格说明书 11.8.5章节，以及这一系列标题为“类型与语法”内容的第4章。


## 变量

在JavaScript 中，变量名（包括函数名）必须是有效的标识符。如果考虑非传统的字符，比如Unicode,那么标识符中严格完整的有效字符规则有一点复杂。如果只考虑典型的ASCII 字母字符，那么规则就简单了。

标识符必须以`a`-`z`， `A`-`Z`， `$` 或者 `_` 开头。标识符可以包含以上所有的字符和数字`0`-`9`。

通常，属性名跟变量标识符的字符串规则一样。但是，某些特定的单词是不能用作变量的，但是可以用于属性名。这些单词称作“保留关键字”， 包含 JS关键字（`for`，`in`，`if`等）以及`null`，`true` 和`false`。

**说明** 更多关于保留关键字的信息，参见这一系列标题为“类型与语法”内容的附加A 。

### 函数作用域

使用`var`关键字声明当前函数作用于的变量，或者在函数外面的最外层声明全局作用于变量。

#### 提升

不管`var`出现在作用域中的什么位置，声明都属于整个作用域，可以被整个作用任何地方访问。

`var`声明被提前到作用域范围内的最上面的这种行为叫“提升”。 技术上来说，这种处理方式更准确地讲是在解释代码如何被编译的，但是我们暂且跳过这些细节。

参见：

```js
var a = 2;

foo();					// 能够运行，因为foo()的声明被提升了。

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// 声明被提升到foo()的最上面
						
}

console.log( a );	// 2
```

**警告** 依靠变量的提升在作用域中提前使用变量而不是在`var`变量声明之后使用的方式并不常见，也不是一个好点子。这样会让人困惑。函数声明提升在它的正式声明之前调用的方式更为常见，就像我们上面的foo()函数。

#### 内嵌作用域

如果声明了一个变量，在那个作用域中的任何地方都是可以访问的，更深层、内部的作用域也可以。例如：

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

变量c 在bar() 中不可访问，因为它只在baz() 作用域中被声明，b 在foo() 中不可访问也是同样的原因。

如果去访问一个在当前作用域下面不可访问的变量值，那么程序会抛出`ReferenceError`错误。如果你给一个尚未声明的变量赋值，要么你会在最顶层作用域增加一个变量，要么会出现报错，这取决于当前代码是否是“严格模式”。让我们来看看：

```js
function foo() {
	a = 1;	// `a` 没有被正式声明
}

foo();
a;			// 1 -- oops, 自动转成全局作用域 :(
```

这不是一个好的练习。不要这么做。变量一定要正式声明。

另外在函数层级创建变量声明的时候，ES6 *let* 关键字可以用来单独代码块作用于中的变量。 除了一些细微的差别之外，它的作用域规则和我们刚刚看到的函数作用域规则大致相同：


```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

因为这里用了`let` 而不是`var`，`b` 的作用域只在if 语句中，而不是在整个foo() 函数中。类似的，`c`只属于`while`循环作用域中。 块作用域适用于细粒度地管理变量作用域，随着时间积累你的代码维护起来会更简单。

**说明** 关于作用域的更多详情，参见这一系列标题为“作用域与闭包”的内容。关于let 块作用域的更多详情参见这一系列标题为“ES6 与未来”的内容。

## 条件语句

除了我们在第1章简单提到的if 语句之外，JavaScript 还提供了一些其他的条件语句机制，让我们来看一下。

有时候你会发现你可能写了一系列`if..else..if`这样的语句：

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

这种结果是能够正常运行的，但是有一点冗长，因为每一种情况你都要为它们指定 a 的测试条件。`switch` 语句是另外一种选择：

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

如果你只希望某一种情况下的语句被执行，`break`很重要。如果你把case 中的break 去掉，那么在某个条件匹配之后还会继续执行接下来case 中的语句，不管接下来的case 条件是不是匹配。这种所谓的“失败”有时候非常有用。

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

这里，如果a 是2 或者 10， “some cool stuff ”语句都会被执行。

JavaScript 中的另一个条件语句是“条件运算符”，也叫二元运算符。它更像是一个`if..else`语句，如：

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

如果测试表达式（这里是`a > 41`）结果为true，第一个从句的结果`"hello"`就会被赋值给b；否则的话第二个从句的结果`"world"` 就会被赋值给b。

条件运算符不一定非得用在赋值的时候，但是那确实是最常见的用法。

**说明** 测试条件和 `switch` 以及 `? :`的其他模式的详细信息，参见这一系列标题为“类型与语法”的内容。

## 严格模式

ES5 中增加了“严格模式”的概念，它约束了某些特性行为。一般这些限制都可视为为了让代码更加安全，更符合规范。另外，遵守严格模式也能让引擎更好的优化你的代码。严格模式是代码的盛举，应该在你所有项目中都使用它。

你可以再单独的函数中使用严格模式，也可以在整个文件中使用严格模式，这取决于你把严格模式编译指示放在哪里：


```js
function foo() {
	"use strict";

	// 这里的代码是严格模式

	function bar() {
		// 这里的代码是严格模式
	}
}

// 这里的代码是严格模式
```

和下面这段进行对比：

```js
"use strict";

function foo() {
	// 这里的代码是严格模式

	function bar() {
		// 这里的代码是严格模式
	}
}

// 这里的代码也是严格模式
```

严格模式与非严格模式一个重要的区别是，严格模式不允许去掉`var` 变量隐式地将变量声明为全局变量：

```js
function foo() {
	"use strict";	// 打开严格模式
	a = 1;			// `var` 缺失，报出 ReferenceError错误
}

foo();
```

如果你在代码中打开严格模式，然后发现很多错误和bug，你可能会尝试去掉严格模式。但是那种纵容自己的本能是不好的。如果严格模式导致你的程序引发问题，基本上这暗示你的项目代码有需要修复的地方。

严格模式不仅能让你的代码更安全，还能优化你的代码，它还指明了这个语言未来的发展趋势。现在就习惯于严格模式的使用比起拖到以后再转换要简单，后面再转换会更难。

**说明** 更多关于严格模式的内容，参见这一系列标题为“类型与语法”的内容第5章。

## 函数作为值


到目前为止，我们已经讨论了JavaScript中函数作为最基本的作用域的机制。再看下下面典型的函数声明语法：

```js
function foo() {
	// ..
}
```

从语义上可能没那么明显，foo 只是闭合作用域外面的一个变量，它是声明的函数的一个引用。函数本身是一个值，就像`42` 或`[1,2,3]`那样。

刚开始这个概念听起来可能会觉得怪怪的，那么花点时间想一下。不仅可以传一个值（参数）给函数，函数本身也可以作为一个值赋给变量，或者作为参数传递给别的函数，或者从别的函数中返回。

这样说来，一个函数值应该被视作一个表达式，就像其他值或者表达式一样。

参见：

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

第一个赋值给变量`foo` 的函数表达式成为匿名函数，因为它没有名字。

第二个函数是有名字的（`bar`），函数作为一个引用，并复制给变量`x`。通常更倾向于使用 “命名函数表达式”，尽管“匿名函数表达式”现在仍然十分常见。

更多的详细信息参见“作用域与闭包”。

### 立即执行函数表达式（IIFEs）


在之前的代码片段中，两个函数表达式都没有被执行。如果要执行必须在代码中写上`foo()` 或者 `x()`。

还有一种执行函数表达式的方式，称为“立即执行函数表达式”。

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```


函数表达式`(function IIFE(){ .. })`外面的`( .. )` 与 JS 语法有细微差别，它是用来避免JS 把它当成普通的函数声明。
 
在表达式`})();` 那里最后的`()` 是表示立即执行之前的函数内容。

这看起来可能怪怪的，但是第一眼看上去并没有那么陌生。对比一下foo 函数和立即执行函数共同点：


```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

你会看到，`()`之前的`(function IIFE(){ .. })` 与 `()`之前的`foo`是一样的。两者的引用都是在加上`()`的时候立即执行。

IIFE 只是一个函数，函数创建了作用域，立即执行函数表达式内部声明的变量就与函数外部环境隔绝了。

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

立即执行行数也能有返回值：

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

立即执行函数执行之后返回的42 被赋值给变量x 。



### 闭包

*闭合* 是JavaScript 中最重要却最难理解的一个概念。为了让你对闭包有一个大致的认知，我会将一点关于它的只是，但不作详细讲解，“作用域与闭包”中会详细说明。闭包将会是你的JS 技能中最重要的一项技术。

你可以把闭包当作是记住函数作用域，然后函数执行完之后仍旧可以继续访问这个函数作用的一种方式。

参见：

```js
function makeAdder(x) {
	// x 参数是一个内部变量

	// 内部函数add 使用了x， 因此这里形成了一个闭包 
	function add(y) {
		return y + x;
	};

	return add;
}
```

每次调用外部函数`makeAdder(..)`的时候被返回出来的内部函数`add(..)`能够记住被传入到 `makeAdder(..)`的x 的值。现在让我们来使用一下`makeAdder(..)`：


```js
// `plusOne` 是传入参数x=1 给外部函数`makeAdder(..)`之后返回的内部函数`add(..)`形成的闭包
var plusOne = makeAdder( 1 );

// `plusTen` 是传入参数x=10 给外部函数`makeAdder(..)`之后返回的内部函数`add(..)`形成的闭包
var plusTen = makeAdder( 10 );

plusOne( 3 );		// 4  <-- 1 + 3
plusOne( 41 );		// 42 <-- 1 + 41

plusTen( 13 );		// 23 <-- 10 + 13
```

这些代码是怎么运行的：

1，当我们调用`makeAdder(1)`的时候，得到了记住了x=1的内部函数`add(..)`的引用。再执行`plusOne(..)`调用这个引用；

2，当我们调用`makeAdder(10)`的时候，得到了另一个记住了x=10的内部函数`add(..)`的引用。再执行`plusTen(..)`调用这个引用；

3，当我们调用`plusOne(3)`的时候，它把3（内部的y）与 1（记住的x值）相加得到的结果4 作为结果；

4，当我们调用`plusTen(13)`的时候，它把13 （内部的y）与 10（记住的x值）相加得到的结果23 作为结果。

可能刚开始会觉得奇怪和困惑，不用担心。要完全弄懂需要多练习几次。

但是，相信我，只要你搞清楚了，这将会是你未来项目中最强大有用的技术之一。你在闭包上付出的努力绝对是值得的。下一章节中，我们会有更多关于闭包的练习。

#### 模块

模块模式是JavaScript 中闭包最常见的使用方式。模块让你可以隔绝外部环境定义私有的实现细节（变量，函数），也可以定义开放API供外部使用。

参见：

```js
function User(){
	var username, password;

	function doLogin(user,pw) {
		username = user;
		password = pw;

		// do the rest of the login work
	}

	var publicAPI = {
		login: doLogin
	};

	return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( "fred", "12Battery34!" );
```

外部作用域`User()` 有两个变量`username` 和 `password`，还有一个内部函数`doLogin()`；这些都是User模块的内部细节，外部无法访问。

**警告** 这里故意不使用`new User()`，尽管对于大多数读者来说那更常见。`User()` 只是一个函数，并不是一个待初始化的类，所以只要正常调用就好了。这里使用`new`反而不合适，而且浪费资源。

执行`User()` 创建了User模块的实例：创建了一个新的作用域，那些内部的变量和函数都被重新拷贝了一份。把这个实例赋值给`fred`，再次执行`User()`的时候又会创建一个与`fred`完全无关的新实例。

`doLogin()`形成了一个依赖`username` 和 `password`的闭包，这意味着它将会在`User()` 执行结束后依然保持对它们的访问。

`publicAPI` 是一个有属性和方法的对象，属性`login`指向内部函数`doLogin()`。从`User()`返回`publicAPI`的时候，它就变成了实例`fred`。

这个时候`User()`已经结束执行了。我们会认为内部的变量像`username` 和 `password`都已经消失了。但是这里没有，因为函数`login()`中的闭包让它们仍然存在。

这就是为什么我们调用`fred.login(..)`和调用内部的`doLogin(..)`是一样的，它们仍能够访问到内部的变量`username` 和 `password`。

这是一个好机会先大致了解下闭包和模块模式，还有一点点困惑这是正常的。要让你的大脑适用它还需要做点功课。

如果想更深层地阅读相关的内容，直接跳到这一系列标题为“作用域与闭包”的章节去。

## `this` 标识符

JavaScript 中另外一个很容易搞错的概念是`this`标识符。这一系列标题为“this 与对象原型” 部分中有几个章节都是关于this 的，所以我们这里只是简单地介绍下这个概念。

可能你会认为`this` 与面向对象编程有关系，但在JS 中`this` 的机制不同。

如果一个函数内部有this 引用，那个this 通常指向一个对象。但是到底指向哪个对象取决于函数是怎样被调用的。

记住，this 不是指向函数本身，这一点最容易被误解的。

快速看下下面的例子：

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined
```

代码片段中最后四行展示了 this 是怎么设置的：

1，`foo()`执行之后，在非严格模式下，this 指向全局对象，“global”就是`this.bar`的值 ；在严格模式下是undefined，这时访问bar 属性就会报错。

2，`obj1.foo()` 将this 指向obj1 对象。

3，`foo.call(obj2)` 将this 指向obj2 对象。

4，`new foo()` 将this 指向一个全新的空对象

为了理解这个this指的是什么，你要思考问题中的函数是怎么被调用的。答案就在上面四种情况之一中能够找到。

**说明** 更多关于this的信息参见这一系列标题为“this 与对象原型”部分的第1，2章内容。

## 原型

JavaScript 中的原型机制非常复杂。我们这里只是先大致看一下。如果要详细了解需要花很多的时间到“this 与对象原型” 部分的第4-6节中去学习。

访问对象中的属性时，如果那个属性不存在，JavaScript 会自动使用对象的内部原型引用去查找别的对象中是否有这个属性。你差不多可以把它看成是如果属性不存在时候的备用对象。

从一个对象到它的备用对象的内部原型链是对象创建的时候就产生的。演示它最简单的方式是使用一个内部功能`Object.create(..)`。

参见：

```js
var foo = {
	a: 42
};

// 创建bar并把它链到foo 
var bar = Object.create( foo );

bar.b = "hello world";

bar.b;		// "hello world"
bar.a;		// 42 <-- delegated to `foo`
```

下图有助于更直观的了解对象foo 和bar 以及它们之间的联系：

<img src="fig6.png">

`a`并不是对象`bar`中真实存在的属性，但是因为bar 在原型上链接到foo，所以JavaScript 会自动地退到foo 对象上去寻找a ，然后它找到了。

这个原型链看起来是这门语言的一个奇怪特性。这个特性最常用的方式是模拟类的继承机制。

不过更自然地应用原型的方式是一种称为“行为代理”的模式，这样你就可以设计一套链接起来的对象，把需要的行为从一个对象代理到别的对象中。

**说明** 更过关于原型和行为代理的详细内容，参见这一系列标题为“this 与原型代理”部分的第4-6章节内容。

## 新旧比较

之前的内容已经涵盖了的大部分JS特性，当然后面还会有一些更新的特性要讲，这些新特性在旧的浏览器中不可用。事实上，JS规格说明书中有些最新的特性甚至在目前的浏览器稳定版本中都还没有实现。

因此，这些新东西我们要怎么办？ 难道我们要等上数年甚至数十年等这些老的浏览器被淘汰后再使用吗？

可能很多人都这么想，但对于JS 的发展来说并不健康。

有两种方式可以让你把JavaScript 的新东西带到就浏览器中：填充和转译。

### 填充

“polyfill” 是Remy Sharp发明的单词，用来表示使用新特性的定义，然后编写与其特性行为一致的代码让它也能够在老的JS环境下面正常运行。

例如，ES6 定义了一个功能叫`Number.isNaN(..)` 用来检测是不是提供了不会引起 的非NaN 值， 废弃了原来的`isNaN(..)`功能。 这个时候就要让代码在不管是新的ES6 还是老的浏览器上正常运行的填充代码就非常简单。

参见：

```js
if (!Number.isNaN) {
	Number.isNaN = function isNaN(x) {
		return x !== x;
	};
}
```

`if` 语句用来检测当前的ES6 浏览器是否已经存在这个功能，如果不存在，那就定义一个`Number.isNaN(..)`。

**说明** 这里使用了NaN 值的小技巧，NaN值是这门语言中唯一一个不会等于自身的值。NaN值是唯一一个执行`x !== x` 会返回true的值。

并非所有的新特性都能进行填充，有的时候大部分行为是可以填充的，但是也有些小例外。在你自己写填充的时候要格外格外小心，要保证你尽量严格遵守了JS 规范。

或者更好的做法是，使用一些[ES5-Shim](https://github.com/es-shims/es5-shim) 和[ES6-Shim](https://github.com/es-shims/es6-shim) 已经审核过的你信任的填充代码。


### 转译

JavaScript 的新增语法是没有办法填充的。新的语法会在老的JS引擎上因无法识别而报错。

这时候更好的选择是使用工具将新语法代码转化成相应的老语法代码。这个过程通常被称为“转译”，变型 + 编译。

本质上你的源码是使用新语法编写的，但是部署到浏览器的其实转译之后的老代码。你要在代码构建过程中插入转译器，跟代码诊断和代码压缩工具一样。

你可能会疑问我为什么要这么麻烦些新语法的代码，然后把它转译成老的代码，为什么不直接写老语法代码？

这里给出了几条原因解释：

* 新语法的设计目的就是为了增加代码可读性和可维护性。对应的老语法通常会更复杂。选择写更新更清新的语法，不仅仅是为了你自己，同时也是为了团队中的其他成员；

* 如果在老的浏览器上使用转译之后的语法，而在最新的浏览器直接使用新语法的好处是，浏览器对新语法的支持性能更优。也让浏览器厂商有更多真实的代码来测试他们的实现和优化；

* 实际工作中越早使用新语法越能提高健壮性，能越早把反馈提交给JavaScript 委员会（TC39）。如果问题及早发现，他们就能在语言设计中出现的失误成为永久性的之前得到修复。

这儿有一个转译的例子。ES6 新增的叫做“默认参数值”的特性。它看起来是这样的：

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

很简单对不对？ 也很实用。但是这个新语法在ES6 之前的引擎中是不合法的。那么转译器会怎么做让它能够在旧的环境下也能正常运行呢？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

正如你所见，首先判断`arguments[0]`的值是不是`void 0`，如果是那么就提供默认值2， 否则就传什么过来就设置什么值。

除了能在旧的浏览器中使用更好的语法之外，转译后的代码更能清楚地解释新语法的行为。

或许只看ES6 版本的语法你还没有意识到`undefined` 是唯一一个不能作为默认参数传递的值，但是转译后的代码就看的更清楚了。

最后一个关于转译需要强调的细节是，转译应该被视为JS 开发生态和发展的标准的一部分。 JS一直在以比以前更快的速度在发展，因此每隔几个月就有新增新的语法和特征。

如果你默认使用了转译器，那么一旦你发现某个新语法很有用你就可以立即开启使用它，而不是等上数年等待今天的浏览器都消失。

这里有一些伟大的转译器供你选择，截止到本书撰写的时候有以下好的选择：

* [Babel](https://babeljs.io) ： 把ES6+ 的语法转译成ES5 

* [Traceur](https://github.com/google/traceur-compiler)： 把ES6 ，ES7以及更高级的语法转译成ES5

## 非JavaScript

到目前为止，我们讨论的都是跟JS 语言自身的东西。现实是大多数JS 在环境中运行或者与环境交互，比如浏览器环境。你写的一大块代码严格地讲，并不是直接被JavaScript 控制。这听起来可能有点奇怪。

你会遇到的最常见的非JavaScript JavaScript 就是DOM API。例如：

```js
var el = document.getElementById( "foo" );
```

在浏览器中运行的时候，变量`document` 作为一个全局变量存在。它既不是JS 引擎提供的，也不是JS规范控制的。它看起来像一个有点丑的普通的JS对象，但有不是真的JS 对象。它是一个特殊的对象，通常称为“宿主对象”。

此外，`document`上的方法`getElementById(..)` 看起来像一个普通的JS 函数，但是它只是浏览器 DOM内建的暴露出来作为接口的方法。在某些新生代浏览器中，这一层是用JS 写的， 但传统的DOM 以及它的行为都是用 C/C++ 这类语言实现的。

另外一个例子是输入输出 I/O。

大家最爱的`alert(..)`会在用户浏览器窗口中弹出一个消息框。`alert(..)`是浏览器提供给JS程序的，而不是JS 引擎本身自带的。调用的时候会发送消息给浏览器内部，然后浏览器渲染和展示消息框。

`console.log(..)`也是一样。浏览器提供了这样的机制，并把它们放在了开发者工具下。

这本书和所有其他系列都把关注点放在JavaScript 语言上。所以你看不到大量讲非JavaScript 的JavaScript 机制。不过，你还是要关注它们，在我们的程序中它们无所不在。

## 复习

学习JavaScript 口味的编程的第一步就是要基本了解它的核心机制，如值，类型，函数闭包，`this`还有原型。

当然，每一个主题都值得更深入地学习，这就是为什么这本书有这么多章节和内容要在接下来的部分中出现了。你对这一章节中的概念和代码示例熟悉了之后，接下来的系列才是真正等着你去挖掘和深入学习的内容。

最后一章节会简短地总结下除了我们已经涉略的内容之外，这一系列书中的其他的一些课题和概念。

