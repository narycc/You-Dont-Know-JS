# 你不知道的JS：起步
# 第2章： 深入JavaScript

在之前的章节中，我介绍了筑立编程的基本砖块：变量，循环，条件语句和函数。当然，所有的示例都是用JavaScript 语言写的。但是在这一章节中，我们会着重关注作为一个JS开发者需要专门了解的JavaScript特性上。

我们将会在这章节中介绍一些后续*YDKJS*系列中才会深入探讨的概念。你可以把它们视作这一系列后续详细介绍的主题的概览。

尤其是作为一个JavaScript初学者，你应该花上足够的时间反复巩固这些概念和代码示例。好的基础都是一块块砖垒起来的，不要寄希望于一步通天。

你深入学习JavaScript 之旅在此启程。

**说明** 就像我在第1章所述，本章所有涉及到的代码你都应该亲自动手尝试。注意这里的一些代码部分使用了截止到写这本书时候最新的一些JavaScript 语法（ES6 一般指ECMAScript 第6版，JS规格说明书的官方名字）。如果你正在使用的浏览器比较陈旧，ES6 浏览器之前的版本，这些代码可能无法正常运行，那么请更新浏览器版本（如Chrome，firefox，或者IE）。 

## 值与类型

正如在第1章中所述，JavaScript 的值是有类型的，变量是没有类型的。以下是内置的类型：

* `string`
* `number`
* `boolean`
* `null` 和 `undefined`
* `object`
* `symbol` （ES6 新增）

JavaScript 有一个typeof 操作符，可以检测值的所属类型。

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

typeof 操作符返回的值总是六个字符串（ES6 的话是7个，还有symbol 类型）中的一个。 `typeof "abc"` 返回的是 `"string"`而不是`string`。

注意，这个代码片段中，a 变量的值是不同的，虽然看起来是一样的`typeof a`，但它不是获取`a` 的类型，而是当前a 变量中存储的值的类型。JavaScript 中只有值有类型，变量只是那些值的一个容器。

`typeof null`比较有趣，可能你会认为它会返回`"null"`，但意外的返回`"object"`。

**警告** 这个bug 在JS中已经存在很久了，但是看起来似乎永远不会被修复了。web中有太多的代码依赖这个这个bug 了，因此一旦修复会引起更多的bug。

同时，注意`a = undefined`，我们显式地给a 设置为undefined ，这种行为跟没有赋值的变量的结果是一样的，如最上面的代码`var a;`。有多种方式将一个变量设置为undefined 状态，包括没有返回值的函数和使用`void` 操作符。

### 对象

`object` 是一个复合值，你可以给它设置属性，并且每个属性可以有任何类型的值。它或许是JavaScript 所有类型中最有用的值类型了。

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

直观地来看这个`obj` 的值：

<img src="fig4.png">

属性可以通过点操作符（`obj.a`）也可以通过方括号引用（`obj["a"]`）来获取。通常更倾向于使用点操作符，因为更短通常也更易读。

方括号引用在属性名字为特殊字符串的时候很有用，比如`obj["hello world!"]`， 这样的属性成为方括号引用的*键*。`[ ]`引用需要一个变量或字符串字面值（常用`" .. "` 或 `' .. '`包裹）。

当然，当键名或者属性名存储在另一个变量中的时候，方括号引用也非常实用，如：
```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**说明** 关于JavaScript `object` 的更多信息，参见这一些列标题为“this 与对象原型” 的内容第三章节。

JavaScript 程序中你通常还会使用到其他值类型：*数组* 和 *函数*。与其说他们是内建类型，到不如说它们更像是子类型，专指 object 类型的子类型。

#### 数组

数组是一个包含多个不是以属性名或键名而是以数字索引值的对象。比如：

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```


**说明** 一些以 0 作为计数开始的语言，比如JS，把0 作为数组第一个元素的索引位置。

直观地来看这个`arr` 的值：

<img src="fig5.png">

数组是特殊的对象（参考 typeof ），它们也可以有属性，包括自动更新的length 属性。

理论上你可以把数组当一个正常的对象使用，提供属性名；类似地你也可以给对象设置数字属性（`0`， `1` 等）。但是，这些都会被视作对应类型使用不当的结果。

数字位置索引的值用数组存储，有属性名的值用对象存储，这是最好最自然的方式。

#### 函数

你的JS程序中会使用到的另外一个`object`子类型是函数：

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

`typeof` 返回 `"function"`表明函数是一个主类型。函数是`object` 的子类型，因此可以有属性值，但是一般你只能在某些情况下使用函数的对象属性（如`foo.bar`）。

**说明** 关于JS值和它们的类型的更多信息，参见这一系列标题为 “值与语法” 的内容前两章节。

### 内建类型方法

我们刚刚讨论的内建类型和子类型暴露出来的属性和方法非常强大非常有用。例如：

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

`a.toUpperCase()` 背后是如何调用的远比方法返回出来的值要复杂的多。

简单地讲，有一个原生的`String`对象封装，与原始的`string` 类型对应，是这个对象封装在它的原型上定义了`toUpperCase()` 方法。

当你使用原始的值如`"hello world"` 作为对象，并调用属性或者方法（如之前代码片段中的 `a.toUpperCase()`），JS 自动地将这个值封装成对象副本。

一个字符串值可以被`String` 对象封装，一个数字可以被`Number`对象封装，一个布尔值可以被`Boolean` 封装。大多数情况，你不用操心如何使用这些值的对象封装形式，任何情况下直接使用原始值的形式， 剩下的就交给JavaScript 就好了。

**说明** 关于JS 原生类型和封装的更多信息，参见这一系列标题为“类型与语法”内容的第3章。 为了更好地理解对象的原型，参见这一系列标题为“this 与对象原型”内容的第5章。

### 值比较

JS程序中有两种主要的值比较类型： 等式与不等式。 不管什么类型的值比较的结果都是严格的布尔类型（true 或false）。

#### 强制转换

我们在第1章节中简要的提及了下强制转换，这里让我们再来看看。

JavaScript 强制转换由两种形式组成：显式和隐式。 显式强制转换指那些你可以明显在代码中看到的从一种类型转换成另一种类型的情况；隐式强制转换是在执行某些操作时发生地不明显的类型转换。

或许事实中很多地方给我们一个结论，“强制转换是魔鬼”，因为他会引起令人意想不到的结果。而没有什么比语言的结果让他们意想不到更令程序员受挫的了。

强制不是魔鬼，它也不是非得让人感到意外。事实上大多数情况下我们进行的类型转换都是非常有意义且易懂的，甚至对提高代码的可读性有很大帮助。但是，我们不会在这里过多的为这个问题争论， 这一系列标题为“类型与语法”的第4章涵盖了所有的优缺点。

这里有一个显式强制转换的例子：

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

这个是隐式强制转换的例子：

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真与假

第1章中，我们简要地提及了值的“真”与“假”本质：当一个非布尔值强制转化成一个布尔值时，它非真即假。

JavaScript 为 false 的值如下：

* `""` （空字符串）
* `0`， `-0`， `NaN` （非法 `number`）
* `null`， `undefined`
* `false`

所有不在上列为“假”中的值，那就是“真”。这是一些例子：

* `"hello"`
* `42`
* `true`
* `[ ]`， `[ 1, "2", 3 ]`（数组）
* `{ }`， `{ a: 42 }`（对象）
* `function foo() { .. }` （函数）

记住，当一个非布尔值强制转化成布尔值的时候只能是“真”或者“假”。并不会有那么复杂，不会有把一个值强制转化成布尔值却不会得到布尔值的情况。

#### 等式

有四种等式表达式： `==`， `===`， `!=`，和 `!==`。`！` 格式的表达式自然是不等于的意思。要区分不等于和不等式的概念。

`==` 和 `===` 的区别是， `==` 检查值是否相等，`===` 检查值和类型是否都相等。但并不完全准确。它们正确的使用方式是允许强制转化检查值是否相等时用 `==`，不允许强制转化检查值是否相等时使用`===`， 因为`===`通常称为严格的相等。

隐式强制转化比较时使用 `==` ，而不能使用严格相等`===`。

```js
var a = "42";
var b = 42;

a == b;			// true
a === b;		// false
```

进行`a == b`比较时，JS发现两者的类型不一样，因此会进行一系列步骤把一个或者两个值转化别的类型，直到它们两者的类型一致，然后再进行简单的值比较。

你想一下就会直到有两种可能的方式让`a==b` 强制转换之后返回true。要么最后变成`42 == 42`的形式，要么变成`"42" == "42"`。那到底是哪一种呢？

答案是`"42"` 变成了 `42`，最后进行的比较是：`42 == 42`。这个简单的例子中，到底是数字转换成字符串进行比较还是字符串转化成数字进行比较不是很关键，因为结果都是一样。更复杂的情况是我们不仅要关心最终的比较结果是什么，还要知道为什么。

`a === b` 的结果是false， 因为不允许强制转换，那么进行简单的值比较肯定是不相等的。很多开发者觉得`===`比较的结果更好预测，因此他们提倡大家始终使用`===` ，远离`==`。我觉得这种观点是非常短视的。我相信`==`非常强大，如果你花时间去学习它的机制，对你的程序是很有帮助的。

我们不准备在这里详细地讨论`==`比较中的强制转化是怎么工作的。大部分很明显，但仍然有一些重要的极端情况需要仔细对待。关于确切的规则，阅读 [ES5 规格说明书的11.9.3章节](http://www.ecma-international.org/ecma-262/5.1/)，你会惊讶地发现比起它那些被放大的缺点，这个机制是多么的直接。

总结所有的细节，为了应对各种使用情况到底使用`==` 还是`===` ，下面是我的一些结论规律：

* 如果比较的两边的值都不是true 或者false， 使用`====`,避免使用`==`；
* 如果比较的任何一边有出现特定的值（`0`，`""` 或 `[]`空数组）使用`===`，避免使用`==`；
* `==`在所有其他情况使用都是安全的，不仅安全，而且多数情况下能简化你的代码提高可读性。

以上总结这些结论都需要你谨慎思考你的代码，进行等式比较的变量的值类型是什么。如果你能确定值，并且`==`是安全的，那么就用`==`。如果你不确定值，那么就使用`===`。就是这么简单。

不等号`!=`与`==`对应，`!==`与`===`对应。我们上面讨论的所有规则和观察结果都适用于这些不等于比较。

当你对两个非原始值进行比较的时候，比如对象（包括函数和数组），你必须特别注意`==` 和`===`的比较规则。因为这些值事实上是保存在引用中，`==` 和 `===`都会去检查引用是否相等，而不只是他们对应的值。

例如，`array` 默认会按照把数组中所有的元素以逗号的形式拼接起来强制转化成字符串。你可能会觉得两个内容相同的数组`==` 比较会相等，但并非如此：

```js
var a = [1,2,3];
var b = [1,2,3];
var c = "1,2,3";

a == c;		// true
b == c;		// true
a == b;		// false
```

**说明** 更多关于`==`等式比较的规则，参见 ES5 规格说明书（11.9.3小节）和 这一系列“类型与语法”内容的第4章节。更多关于值和引用的内容，参见第2章。

#### 不等式

不等式，在规格说明书中被称为关系比较，使用`<`， `>`， `<=` 和 `>=` 运算符。通常被用来进行普通的值比较，如数字。通俗易懂，如`3 < 4`。

但是JavaScript 的string 类型值也能按照字母顺序规则进行不等式比较（`"bar" < "foo"`）。

那么强制转化呢？不等式的比较规则跟`==`类似。和“严格相等”`===` 不支持强制转换一样， “严格不等”运算符也不支持强制转换。

参见：

```js
var a = 41;
var b = "42";
var c = "43";

a < b;		// true
b < c;		// true
```

这里发生了什么呢？ 在ES5 规格说明书的 11.8.5 章节中阐述，如果`<`两遍的值都是字符串类型，像这里的`b < c`，是按照字典序比较的。但是只要有一边不是字符串，像这里的`a < b`，那么两边的值都会被强制转化成数字，然后就成变了典型的数字比较。

这里没有“严格的不等式”，你在不同值类型比较中的可能会遇到的最大问题是，其中的一个值不能转化成有效的数字，比如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

等等，怎么会这三个比较都返回false 呢？ 因为在`<`，`>`比较中b 被强制转化成非法的数字`NaN`，JS规格说明书中说，NaN 既不会大于也不会小于任何值。

`==` 不成立是因为别的原因。如之前解释的，如果比较被转换成`42 == NaN` 或 `"42" == "foo"`那么`a == b`就不会成立，这里就是`42 == NaN`。

**说明** 想了解更多关于不等式比较规则的详细信息，参见ES5规格说明书 11.8.5章节，以及这一系列标题为“类型与语法”内容的第4章。


## 变量

在JavaScript 中，变量名（包括函数名）必须是有效的标识符。如果考虑非传统的字符，比如Unicode,那么标识符中严格完整的有效字符规则有一点复杂。如果只考虑典型的ASCII 字母字符，那么规则就简单了。

标识符必须以`a`-`z`， `A`-`Z`， `$` 或者 `_` 开头。标识符可以包含以上所有的字符和数字`0`-`9`。

通常，属性名跟变量标识符的字符串规则一样。但是，某些特定的单词是不能用作变量的，但是可以用于属性名。这些单词称作“保留关键字”， 包含 JS关键字（`for`，`in`，`if`等）以及`null`，`true` 和`false`。

**说明** 更多关于保留关键字的信息，参见这一系列标题为“类型与语法”内容的附加A 。

### 函数作用域

使用`var`关键字声明当前函数作用于的变量，或者在函数外面的最外层声明全局作用于变量。

#### 提升

不管`var`出现在作用域中的什么位置，声明都属于整个作用域，可以被整个作用任何地方访问。

`var`声明被提前到作用域范围内的最上面的这种行为叫“提升”。 技术上来说，这种处理方式更准确地讲是在解释代码如何被编译的，但是我们暂且跳过这些细节。

参见：

```js
var a = 2;

foo();					// 能够运行，因为foo()的声明被提升了。

function foo() {
	a = 3;

	console.log( a );	// 3

	var a;				// 声明被提升到foo()的最上面
						
}

console.log( a );	// 2
```

**警告** 依靠变量的提升在作用域中提前使用变量而不是在`var`变量声明之后使用的方式并不常见，也不是一个好点子。这样会让人困惑。函数声明提升在它的正式声明之前调用的方式更为常见，就像我们上面的foo()函数。

#### 内嵌作用域

如果声明了一个变量，在那个作用域中的任何地方都是可以访问的，更深层、内部的作用域也可以。例如：

```js
function foo() {
	var a = 1;

	function bar() {
		var b = 2;

		function baz() {
			var c = 3;

			console.log( a, b, c );	// 1 2 3
		}

		baz();
		console.log( a, b );		// 1 2
	}

	bar();
	console.log( a );				// 1
}

foo();
```

变量c 在bar() 中不可访问，因为它只在baz() 作用域中被声明，b 在foo() 中不可访问也是同样的原因。

如果去访问一个在当前作用域下面不可访问的变量值，那么程序会抛出`ReferenceError`错误。如果你给一个尚未声明的变量赋值，要么你会在最顶层作用域增加一个变量，要么会出现报错，这取决于当前代码是否是“严格模式”。让我们来看看：

```js
function foo() {
	a = 1;	// `a` 没有被正式声明
}

foo();
a;			// 1 -- oops, 自动转成全局作用域 :(
```

这不是一个好的练习。不要这么做。变量一定要正式声明。

另外在函数层级创建变量声明的时候，ES6 *let* 关键字可以用来单独代码块作用于中的变量。 除了一些细微的差别之外，它的作用域规则和我们刚刚看到的函数作用域规则大致相同：


```js
function foo() {
	var a = 1;

	if (a >= 1) {
		let b = 2;

		while (b < 5) {
			let c = b * 2;
			b++;

			console.log( a + c );
		}
	}
}

foo();
// 5 7 9
```

因为这里用了`let` 而不是`var`，`b` 的作用域只在if 语句中，而不是在整个foo() 函数中。类似的，`c`只属于`while`循环作用域中。 块作用域适用于细粒度地管理变量作用域，随着时间积累你的代码维护起来会更简单。

**说明** 关于作用域的更多详情，参见这一系列标题为“作用域与闭包”的内容。关于let 块作用域的更多详情参见这一系列标题为“ES6 与未来”的内容。

## 条件语句

除了我们在第1章简单提到的if 语句之外，JavaScript 还提供了一些其他的条件语句机制，让我们来看一下。

有时候你会发现你可能写了一系列`if..else..if`这样的语句：

```js
if (a == 2) {
	// do something
}
else if (a == 10) {
	// do another thing
}
else if (a == 42) {
	// do yet another thing
}
else {
	// fallback to here
}
```

这种结果是能够正常运行的，但是有一点冗长，因为每一种情况你都要为它们指定 a 的测试条件。`switch` 语句是另外一种选择：

```js
switch (a) {
	case 2:
		// do something
		break;
	case 10:
		// do another thing
		break;
	case 42:
		// do yet another thing
		break;
	default:
		// fallback to here
}
```

如果你只希望某一种情况下的语句被执行，`break`很重要。如果你把case 中的break 去掉，那么在某个条件匹配之后还会继续执行接下来case 中的语句，不管接下来的case 条件是不是匹配。这种所谓的“失败”有时候非常有用。

```js
switch (a) {
	case 2:
	case 10:
		// some cool stuff
		break;
	case 42:
		// other stuff
		break;
	default:
		// fallback
}
```

这里，如果a 是2 或者 10， “some cool stuff ”语句都会被执行。

JavaScript 中的另一个条件语句是“条件运算符”，也叫二元运算符。它更像是一个`if..else`语句，如：

```js
var a = 42;

var b = (a > 41) ? "hello" : "world";

// similar to:

// if (a > 41) {
//    b = "hello";
// }
// else {
//    b = "world";
// }
```

如果测试表达式（这里是`a > 41`）结果为true，第一个从句的结果`"hello"`就会被赋值给b；否则的话第二个从句的结果`"world"` 就会被赋值给b。

条件运算符不一定非得用在赋值的时候，但是那确实是最常见的用法。

**说明** 测试条件和 `switch` 以及 `? :`的其他模式的详细信息，参见这一系列标题为“类型与语法”的内容。

## 严格模式

ES5 中增加了“严格模式”的概念，它约束了某些特性行为。一般这些限制都可视为为了让代码更加安全，更符合规范。另外，遵守严格模式也能让引擎更好的优化你的代码。严格模式是代码的盛举，应该在你所有项目中都使用它。

你可以再单独的函数中使用严格模式，也可以在整个文件中使用严格模式，这取决于你把严格模式编译指示放在哪里：


```js
function foo() {
	"use strict";

	// 这里的代码是严格模式

	function bar() {
		// 这里的代码是严格模式
	}
}

// 这里的代码是严格模式
```

和下面这段进行对比：

```js
"use strict";

function foo() {
	// 这里的代码是严格模式

	function bar() {
		// 这里的代码是严格模式
	}
}

// 这里的代码也是严格模式
```

严格模式与非严格模式一个重要的区别是，严格模式不允许去掉`var` 变量隐式地将变量声明为全局变量：

```js
function foo() {
	"use strict";	// 打开严格模式
	a = 1;			// `var` 缺失，报出 ReferenceError错误
}

foo();
```

如果你在代码中打开严格模式，然后发现很多错误和bug，你可能会尝试去掉严格模式。但是那种纵容自己的本能是不好的。如果严格模式导致你的程序引发问题，基本上这暗示你的项目代码有需要修复的地方。

严格模式不仅能让你的代码更安全，还能优化你的代码，它还指明了这个语言未来的发展趋势。现在就习惯于严格模式的使用比起拖到以后再转换要简单，后面再转换会更难。

**说明** 更多关于严格模式的内容，参见这一系列标题为“类型与语法”的内容第5章。

## 函数作为值


到目前为止，我们已经讨论了JavaScript中函数作为最基本的作用域的机制。再看下下面典型的函数声明语法：

```js
function foo() {
	// ..
}
```

从语义上可能没那么明显，foo 只是闭合作用域外面的一个变量，它是声明的函数的一个引用。函数本身是一个值，就像`42` 或`[1,2,3]`那样。

刚开始这个概念听起来可能会觉得怪怪的，那么花点时间想一下。不仅可以传一个值（参数）给函数，函数本身也可以作为一个值赋给变量，或者作为参数传递给别的函数，或者从别的函数中返回。

这样说来，一个函数值应该被视作一个表达式，就像其他值或者表达式一样。

参见：

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

第一个赋值给变量`foo` 的函数表达式成为匿名函数，因为它没有名字。

第二个函数是有名字的（`bar`），函数作为一个引用，并复制给变量`x`。通常更倾向于使用 “命名函数表达式”，尽管“匿名函数表达式”现在仍然十分常见。

更多的详细信息参见“作用域与闭包”。

### 立即执行函数表达式（IIFEs）


在之前的代码片段中，两个函数表达式都没有被执行。如果要执行必须在代码中写上`foo()` 或者 `x()`。

还有一种执行函数表达式的方式，称为“立即执行函数表达式”。

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```


函数表达式`(function IIFE(){ .. })`外面的`( .. )` 与 JS 语法有细微差别，它是用来避免JS 把它当成普通的函数声明。
 
在表达式`})();` 那里最后的`()` 是表示立即执行之前的函数内容。

这看起来可能怪怪的，但是第一眼看上去并没有那么陌生。对比一下foo 函数和立即执行函数共同点：


```js
function foo() { .. }

// `foo` function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

你会看到，`()`之前的`(function IIFE(){ .. })` 与 `()`之前的`foo`是一样的。两者的引用都是在加上`()`的时候立即执行。

IIFE 只是一个函数，函数创建了作用域，立即执行函数表达式内部声明的变量就与函数外部环境隔绝了。

```js
var a = 42;

(function IIFE(){
	var a = 10;
	console.log( a );	// 10
})();

console.log( a );		// 42
```

立即执行行数也能有返回值：

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

立即执行函数执行之后返回的42 被赋值给变量x 。

