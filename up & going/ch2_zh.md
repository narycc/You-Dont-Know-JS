# 你不知道的JS：起步
# 第2章： 深入JavaScript

在之前的章节中，我介绍了筑立编程的基本砖块：变量，循环，条件语句和函数。当然，所有的示例都是用JavaScript 语言写的。但是在这一章节中，我们会着重关注作为一个JS开发者需要专门了解的JavaScript特性上。

我们将会在这章节中介绍一些后续*YDKJS*系列中才会深入探讨的概念。你可以把它们视作这一系列后续详细介绍的主题的概览。

尤其是作为一个JavaScript初学者，你应该花上足够的时间反复巩固这些概念和代码示例。好的基础都是一块块砖垒起来的，不要寄希望于一步通天。

你深入学习JavaScript 之旅在此启程。

**说明** 就像我在第1章所述，本章所有涉及到的代码你都应该亲自动手尝试。注意这里的一些代码部分使用了截止到写这本书时候最新的一些JavaScript 语法（ES6 一般指ECMAScript 第6版，JS规格说明书的官方名字）。如果你正在使用的浏览器比较陈旧，ES6 浏览器之前的版本，这些代码可能无法正常运行，那么请更新浏览器版本（如Chrome，firefox，或者IE）。 

## 值与类型

正如在第1章中所述，JavaScript 的值是有类型的，变量是没有类型的。以下是内置的类型：

* `string`
* `number`
* `boolean`
* `null` 和 `undefined`
* `object`
* `symbol` （ES6 新增）

JavaScript 有一个typeof 操作符，可以检测值的所属类型。

```js
var a;
typeof a;				// "undefined"

a = "hello world";
typeof a;				// "string"

a = 42;
typeof a;				// "number"

a = true;
typeof a;				// "boolean"

a = null;
typeof a;				// "object" -- weird, bug

a = undefined;
typeof a;				// "undefined"

a = { b: "c" };
typeof a;				// "object"
```

typeof 操作符返回的值总是六个字符串（ES6 的话是7个，还有symbol 类型）中的一个。 `typeof "abc"` 返回的是 `"string"`而不是`string`。

注意，这个代码片段中，a 变量的值是不同的，虽然看起来是一样的`typeof a`，但它不是获取`a` 的类型，而是当前a 变量中存储的值的类型。JavaScript 中只有值有类型，变量只是那些值的一个容器。

`typeof null`比较有趣，可能你会认为它会返回`"null"`，但意外的返回`"object"`。

**警告** 这个bug 在JS中已经存在很久了，但是看起来似乎永远不会被修复了。web中有太多的代码依赖这个这个bug 了，因此一旦修复会引起更多的bug。

同时，注意`a = undefined`，我们显式地给a 设置为undefined ，这种行为跟没有赋值的变量的结果是一样的，如最上面的代码`var a;`。有多种方式将一个变量设置为undefined 状态，包括没有返回值的函数和使用`void` 操作符。

### 对象

`object` 是一个复合值，你可以给它设置属性，并且每个属性可以有任何类型的值。它或许是JavaScript 所有类型中最有用的值类型了。

```js
var obj = {
	a: "hello world",
	b: 42,
	c: true
};

obj.a;		// "hello world"
obj.b;		// 42
obj.c;		// true

obj["a"];	// "hello world"
obj["b"];	// 42
obj["c"];	// true
```

直观地来看这个`obj` 的值：

<img src="fig4.png">

属性可以通过点操作符（`obj.a`）也可以通过方括号引用（`obj["a"]`）来获取。通常更倾向于使用点操作符，因为更短通常也更易读。

方括号引用在属性名字为特殊字符串的时候很有用，比如`obj["hello world!"]`， 这样的属性成为方括号引用的*键*。`[ ]`引用需要一个变量或字符串字面值（常用`" .. "` 或 `' .. '`包裹）。

当然，当键名或者属性名存储在另一个变量中的时候，方括号引用也非常实用，如：
```js
var obj = {
	a: "hello world",
	b: 42
};

var b = "a";

obj[b];			// "hello world"
obj["b"];		// 42
```

**说明** 关于JavaScript `object` 的更多信息，参见这一些列标题为“this 与对象原型” 的内容第三章节。

JavaScript 程序中你通常还会使用到其他值类型：*数组* 和 *函数*。与其说他们是内建类型，到不如说它们更像是子类型，专指 object 类型的子类型。

#### 数组

数组是一个包含多个不是以属性名或键名而是以数字索引值的对象。比如：

```js
var arr = [
	"hello world",
	42,
	true
];

arr[0];			// "hello world"
arr[1];			// 42
arr[2];			// true
arr.length;		// 3

typeof arr;		// "object"
```


**说明** 一些以 0 作为计数开始的语言，比如JS，把0 作为数组第一个元素的索引位置。

直观地来看这个`arr` 的值：

<img src="fig5.png">

数组是特殊的对象（参考 typeof ），它们也可以有属性，包括自动更新的length 属性。

理论上你可以把数组当一个正常的对象使用，提供属性名；类似地你也可以给对象设置数字属性（`0`， `1` 等）。但是，这些都会被视作对应类型使用不当的结果。

数字位置索引的值用数组存储，有属性名的值用对象存储，这是最好最自然的方式。

#### 函数

你的JS程序中会使用到的另外一个`object`子类型是函数：

```js
function foo() {
	return 42;
}

foo.bar = "hello world";

typeof foo;			// "function"
typeof foo();		// "number"
typeof foo.bar;		// "string"
```

`typeof` 返回 `"function"`表明函数是一个主类型。函数是`object` 的子类型，因此可以有属性值，但是一般你只能在某些情况下使用函数的对象属性（如`foo.bar`）。

**说明** 关于JS值和它们的类型的更多信息，参见这一系列标题为 “值与语法” 的内容前两章节。

### 内建类型方法

我们刚刚讨论的内建类型和子类型暴露出来的属性和方法非常强大非常有用。例如：

```js
var a = "hello world";
var b = 3.14159;

a.length;				// 11
a.toUpperCase();		// "HELLO WORLD"
b.toFixed(4);			// "3.1416"
```

`a.toUpperCase()` 背后是如何调用的远比方法返回出来的值要复杂的多。

简单地讲，有一个原生的`String`对象封装，与原始的`string` 类型对应，是这个对象封装在它的原型上定义了`toUpperCase()` 方法。

当你使用原始的值如`"hello world"` 作为对象，并调用属性或者方法（如之前代码片段中的 `a.toUpperCase()`），JS 自动地将这个值封装成对象副本。

一个字符串值可以被`String` 对象封装，一个数字可以被`Number`对象封装，一个布尔值可以被`Boolean` 封装。大多数情况，你不用操心如何使用这些值的对象封装形式，任何情况下直接使用原始值的形式， 剩下的就交给JavaScript 就好了。

**说明** 关于JS 原生类型和封装的更多信息，参见这一系列标题为“类型与语法”内容的第3章。 为了更好地理解对象的原型，参见这一系列标题为“this 与对象原型”内容的第5章。

### 值比较

JS程序中有两种主要的值比较类型： 等式与不等式。 不管什么类型的值比较的结果都是严格的布尔类型（true 或false）。

#### 强制转换

我们在第1章节中简要的提及了下强制转换，这里让我们再来看看。

JavaScript 强制转换由两种形式组成：显式和隐式。 显式强制转换指那些你可以明显在代码中看到的从一种类型转换成另一种类型的情况；隐式强制转换是在执行某些操作时发生地不明显的类型转换。

或许事实中很多地方给我们一个结论，“强制转换是魔鬼”，因为他会引起令人意想不到的结果。而没有什么比语言的结果让他们意想不到更令程序员受挫的了。

强制不是魔鬼，它也不是非得让人感到意外。事实上大多数情况下我们进行的类型转换都是非常有意义且易懂的，甚至对提高代码的可读性有很大帮助。但是，我们不会在这里过多的为这个问题争论， 这一系列标题为“类型与语法”的第4章涵盖了所有的优缺点。

这里有一个显式强制转换的例子：

```js
var a = "42";

var b = Number( a );

a;				// "42"
b;				// 42 -- the number!
```

这个是隐式强制转换的例子：

```js
var a = "42";

var b = a * 1;	// "42" implicitly coerced to 42 here

a;				// "42"
b;				// 42 -- the number!
```

#### 真与假

第1章中，我们简要地提及了值的“真”与“假”本质：当一个非布尔值强制转化成一个布尔值时，它非真即假。

JavaScript 为 false 的值如下：

* `""` （空字符串）
* `0`， `-0`， `NaN` （非法 `number`）
* `null`， `undefined`
* `false`

所有不在上列为“假”中的值，那就是“真”。这是一些例子：

* `"hello"`
* `42`
* `true`
* `[ ]`， `[ 1, "2", 3 ]`（数组）
* `{ }`， `{ a: 42 }`（对象）
* `function foo() { .. }` （函数）

记住，当一个非布尔值强制转化成布尔值的时候只能是“真”或者“假”。并不会有那么复杂，不会有把一个值强制转化成布尔值却不会得到布尔值的情况。
